<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Login</title>
  <script>
    // SSSModuleの定義
    !function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).SSSModule = {}) }(this, function (e) { "use strict"; e.getActiveAccountToken = (e, t, i) => { if ("string" == typeof e) return window.SSS.getActiveAccountToken(e, t, i); { const n = e.publicKey; return e.address.pretty().charAt(0) !== window.SSS.activeAddress.charAt(0) ? new Promise((e, t) => { t("Incorrect network type") }) : window.SSS.getActiveAccountToken(n, t, i) } }, e.getActiveAddress = () => window.SSS.activeAddress, e.getActiveName = () => window.SSS.activeName, e.getActiveNetworkType = () => window.SSS.activeNetworkType, e.getActivePublicKey = () => window.SSS.activePublicKey, e.isAllowedSSS = () => !!window.SSS, e.requestSSS = () => window.requestSSS(), e.requestSign = () => window.SSS.requestSign(), e.requestSignCosignatureTransaction = () => window.SSS.requestSignCosignatureTransaction(), e.requestSignEncription = () => window.SSS.requestSignEncription(), e.requestSignWithCosignatories = e => window.SSS.requestSignWithCosignatories(e), e.setMessage = (e, t) => { window.SSS.setMessage(e, t) }, e.setTransaction = e => window.SSS.setTransaction(e), e.setTransactionByPayload = e => window.SSS.setTransactionByPayload(e) });
  </script>
  <script type="module">
    // Symbol Sign Transaction Generator (ESMモジュール版)
    /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    function t(t) { return t instanceof Uint8Array || ArrayBuffer.isView(t) && "Uint8Array" === t.constructor.name } function r(t) { if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t) } function n(r, ...n) { if (!t(r)) throw new Error("Uint8Array expected"); if (n.length > 0 && !n.includes(r.length)) throw new Error("Uint8Array expected of length " + n + ", got length=" + r.length) } function i(t, r = !0) { if (t.destroyed) throw new Error("Hash instance has been destroyed"); if (r && t.finished) throw new Error("Hash#digest() has already been called") } function s(t, r) { n(t); const i = r.outputLen; if (t.length < i) throw new Error("digestInto() expects output buffer of length at least " + i) } function e(t) { return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)) } function o(...t) { for (let r = 0; r < t.length; r++)t[r].fill(0) } function h(t) { return new DataView(t.buffer, t.byteOffset, t.byteLength) } function c(t, r) { return t << r | t >>> 32 - r >>> 0 } function f(t) { return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255 } function u(t) { for (let r = 0; r < t.length; r++)t[r] = f(t[r]); return t } const a = (() => 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0])() ? t => t : u; function l(t) { if ("string" != typeof t) throw new Error("string expected"); return new Uint8Array((new TextEncoder).encode(t)) } function w(t) { return "string" == typeof t && (t = l(t)), n(t), t } class y { } function d(t) { const r = r => t().update(w(r)).digest(), n = t(); return r.outputLen = n.outputLen, r.blockLen = n.blockLen, r.create = () => t(), r } function g(t, r, n, i) { if ("function" == typeof t.setBigUint64) return t.setBigUint64(r, n, i); const s = BigInt(32), e = BigInt(4294967295), o = Number(n >> s & e), h = Number(n & e), c = i ? 4 : 0, f = i ? 0 : 4; t.setUint32(r + c, o, i), t.setUint32(r + f, h, i) } class A extends y { constructor(t, r, n, i) { super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.buffer = new Uint8Array(t), this.view = h(this.buffer) } update(t) { i(this), n(t = w(t)); const { view: r, buffer: s, blockLen: e } = this, o = t.length; for (let n = 0; n < o;) { const i = Math.min(e - this.pos, o - n); if (i === e) { const r = h(t); for (; e <= o - n; n += e)this.process(r, n); continue } s.set(t.subarray(n, n + i), this.pos), this.pos += i, n += i, this.pos === e && (this.process(r, 0), this.pos = 0) } return this.length += t.length, this.roundClean(), this } digestInto(t) { i(this), s(t, this), this.finished = !0; const { buffer: r, view: n, blockLen: e, isLE: c } = this; let { pos: f } = this; r[f++] = 128, o(this.buffer.subarray(f)), this.padOffset > e - f && (this.process(n, 0), f = 0); for (let t = f; t < e; t++)r[t] = 0; g(n, e - 8, BigInt(8 * this.length), c), this.process(n, 0); const u = h(t), a = this.outputLen; if (a % 4) throw new Error("_sha2: outputLen should be aligned to 32bit"); const l = a / 4, w = this.get(); if (l > w.length) throw new Error("_sha2: outputLen bigger than state"); for (let t = 0; t < l; t++)u.setUint32(4 * t, w[t], c) } digest() { const { buffer: t, outputLen: r } = this; this.digestInto(t); const n = t.slice(0, r); return this.destroy(), n } t(t) { t || (t = new this.constructor), t.set(...this.get()); const { blockLen: r, buffer: n, length: i, finished: s, destroyed: e, pos: o } = this; return t.destroyed = e, t.finished = s, t.length = i, t.pos = o, i % r && t.buffer.set(n), t } clone() { return this.t() } } const p = Uint8Array.from([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), U = (() => Uint8Array.from(new Array(16).fill(0).map((t, r) => r)))(), b = (() => U.map(t => (9 * t + 5) % 16))(), I = (() => { const t = [[U], [b]]; for (let r = 0; r < 4; r++)for (let n of t) n.push(n[r].map(t => p[t])); return t })(), E = (() => I[0])(), x = (() => I[1])(), B = [[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map(t => Uint8Array.from(t)), L = E.map((t, r) => t.map(t => B[r][t])), k = x.map((t, r) => t.map(t => B[r][t])), N = Uint32Array.from([0, 1518500249, 1859775393, 2400959708, 2840853838]), m = Uint32Array.from([1352829926, 1548603684, 1836072691, 2053994217, 0]); function M(t, r, n, i) { return 0 === t ? r ^ n ^ i : 1 === t ? r & n | ~r & i : 2 === t ? (r | ~n) ^ i : 3 === t ? r & i | n & ~i : r ^ (n | ~i) } const _ = new Uint32Array(16); class v extends A { constructor() { super(64, 20, 8, !0), this.h0 = 1732584193 | 0, this.h1 = 4023233417 | 0, this.h2 = 2562383102 | 0, this.h3 = 271733878 | 0, this.h4 = 3285377520 | 0 } get() { const { h0: t, h1: r, h2: n, h3: i, h4: s } = this; return [t, r, n, i, s] } set(t, r, n, i, s) { this.h0 = 0 | t, this.h1 = 0 | r, this.h2 = 0 | n, this.h3 = 0 | i, this.h4 = 0 | s } process(t, r) { for (let n = 0; n < 16; n++, r += 4)_[n] = t.getUint32(r, !0); let n = 0 | this.h0, i = n, s = 0 | this.h1, e = s, o = 0 | this.h2, h = o, f = 0 | this.h3, u = f, a = 0 | this.h4, l = a; for (let t = 0; t < 5; t++) { const r = 4 - t, w = N[t], y = m[t], d = E[t], g = x[t], A = L[t], p = k[t]; for (let r = 0; r < 16; r++) { const i = c(n + M(t, s, o, f) + _[d[r]] + w, A[r]) + a | 0; n = a, a = f, f = 0 | c(o, 10), o = s, s = i } for (let t = 0; t < 16; t++) { const n = c(i + M(r, e, h, u) + _[g[t]] + y, p[t]) + l | 0; i = l, l = u, u = 0 | c(h, 10), h = e, e = n } } this.set(this.h1 + o + u | 0, this.h2 + f + l | 0, this.h3 + a + i | 0, this.h4 + n + e | 0, this.h0 + s + h | 0) } roundClean() { o(_) } destroy() { this.destroyed = !0, o(this.buffer), this.set(0, 0, 0, 0, 0) } } const F = d(() => new v), H = BigInt(2 ** 32 - 1), O = BigInt(32); function T(t, r = !1) { return r ? { h: Number(t & H), l: Number(t >> O & H) } : { h: 0 | Number(t >> O & H), l: 0 | Number(t & H) } } function X(t, r = !1) { const n = t.length; let i = new Uint32Array(n), s = new Uint32Array(n); for (let e = 0; e < n; e++) { const { h: n, l: o } = T(t[e], r);[i[e], s[e]] = [n, o] } return [i, s] } const C = (t, r, n) => t << n | r >>> 32 - n, D = (t, r, n) => r << n | t >>> 32 - n, V = (t, r, n) => r << n - 32 | t >>> 64 - n, G = (t, r, n) => t << n - 32 | r >>> 64 - n, J = BigInt(0), K = BigInt(1), P = BigInt(2), Q = BigInt(7), R = BigInt(256), S = BigInt(113), W = [], Y = [], Z = []; for (let t = 0, r = K, n = 1, i = 0; t < 24; t++) { [n, i] = [i, (2 * n + 3 * i) % 5], W.push(2 * (5 * i + n)), Y.push((t + 1) * (t + 2) / 2 % 64); let s = J; for (let t = 0; t < 7; t++)r = (r << K ^ (r >> Q) * S) % R, r & P && (s ^= K << (K << BigInt(t)) - K); Z.push(s) } const j = X(Z, !0), q = j[0], z = j[1], $ = (t, r, n) => n > 32 ? V(t, r, n) : C(t, r, n), tt = (t, r, n) => n > 32 ? G(t, r, n) : D(t, r, n); function rt(t, r = 24) { const n = new Uint32Array(5 * 2); for (let i = 24 - r; i < 24; i++) { for (let r = 0; r < 10; r++)n[r] = t[r] ^ t[r + 10] ^ t[r + 20] ^ t[r + 30] ^ t[r + 40]; for (let r = 0; r < 10; r += 2) { const i = (r + 8) % 10, s = (r + 2) % 10, e = n[s], o = n[s + 1], h = $(e, o, 1) ^ n[i], c = tt(e, o, 1) ^ n[i + 1]; for (let n = 0; n < 50; n += 10)t[r + n] ^= h, t[r + n + 1] ^= c } let r = t[2], s = t[3]; for (let n = 0; n < 24; n++) { const i = Y[n], e = $(r, s, i), o = tt(r, s, i), h = W[n]; r = t[h], s = t[h + 1], t[h] = e, t[h + 1] = o } for (let r = 0; r < 50; r += 10) { for (let i = 0; i < 10; i++)n[i] = t[r + i]; for (let i = 0; i < 10; i++)t[r + i] ^= ~n[(i + 2) % 10] & n[(i + 4) % 10] } t[0] ^= q[i], t[1] ^= z[i] } o(n) } class nt extends y { constructor(t, n, i, s = !1, o = 24) { if (super(), this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, this.enableXOF = !1, this.blockLen = t, this.suffix = n, this.outputLen = i, this.enableXOF = s, this.rounds = o, r(i), !(0 < t && t < 200)) throw new Error("only keccak-f1600 function is supported"); this.state = new Uint8Array(200), this.state32 = e(this.state) } clone() { return this.t() } keccak() { a(this.state32), rt(this.state32, this.rounds), a(this.state32), this.posOut = 0, this.pos = 0 } update(t) { i(this), n(t = w(t)); const { blockLen: r, state: s } = this, e = t.length; for (let n = 0; n < e;) { const i = Math.min(r - this.pos, e - n); for (let r = 0; r < i; r++)s[this.pos++] ^= t[n++]; this.pos === r && this.keccak() } return this } finish() { if (this.finished) return; this.finished = !0; const { state: t, suffix: r, pos: n, blockLen: i } = this; t[n] ^= r, 128 & r && n === i - 1 && this.keccak(), t[i - 1] ^= 128, this.keccak() } writeInto(t) { i(this, !1), n(t), this.finish(); const r = this.state, { blockLen: s } = this; for (let n = 0, i = t.length; n < i;) { this.posOut >= s && this.keccak(); const e = Math.min(s - this.posOut, i - n); t.set(r.subarray(this.posOut, this.posOut + e), n), this.posOut += e, n += e } return t } xofInto(t) { if (!this.enableXOF) throw new Error("XOF is not possible for this instance"); return this.writeInto(t) } xof(t) { return r(t), this.xofInto(new Uint8Array(t)) } digestInto(t) { if (s(t, this), this.finished) throw new Error("digest() was already called"); return this.writeInto(t), this.destroy(), t } digest() { return this.digestInto(new Uint8Array(this.outputLen)) } destroy() { this.destroyed = !0, o(this.state) } t(t) { const { blockLen: r, suffix: n, outputLen: i, rounds: s, enableXOF: e } = this; return t || (t = new nt(r, n, i, e, s)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = s, t.suffix = n, t.outputLen = i, t.enableXOF = e, t.destroyed = this.destroyed, t } } const it = (t, r, n) => d(() => new nt(r, t, n)), st = (() => it(6, 136, 256 / 8))(), et = t => new Uint8Array(t.match(/.{1,2}/g).map(t => parseInt(t, 16))), ot = t => Array.from(t, t => t.toString(16).padStart(2, "0")).join(""), ht = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", ct = t => { let r = 0, n = 0, i = ""; for (const s of et(t)) for (n = n << 8 | s, r += 8; r >= 5;)i += ht[n >>> r - 5 & 31], r -= 5; return r > 0 && (i += ht[n << 5 - r & 31]), i }, ft = t => { let r = 0, n = 0, i = ""; for (const s of t) for (n = n << 5 | ht.indexOf(s), r += 5; r >= 8;)i += (n >>> r - 8 & 255).toString(16).padStart(2, "0"), r -= 8; return i.toUpperCase() }, ut = (t, r) => { const n = F(st(et(r))), i = new Uint8Array([t, ...n]), s = st(i).slice(0, 3); return ct(ot(new Uint8Array([...i, ...s]))) }, at = (t, r) => { const n = "0000000000000000000000000000000000000000000000000000000000000000"; return (() => { const t = 160 + r.length, n = new Uint8Array(4); return n[0] = 255 & t, n[1] = t >> 8 & 255, n[2] = t >> 16 & 255, n[3] = t >> 24 & 255, Array.from(n).map(t => t.toString(16).padStart(2, "0")).join("").toUpperCase() })() + "00000000" + "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" + n + "00000000" + "01" + t.toString(16).padStart(2, "0").toUpperCase() + "5441" + "0000000000000000" + "0000000000000000" + ft(ut(t, n)) + (() => { const t = r.length, n = new Uint8Array(2); return n[0] = 255 & t, n[1] = t >> 8 & 255, Array.from(n).map(t => t.toString(16).padStart(2, "0")).join("").toUpperCase() })() + "00" + "00000000" + "00" + Array.from((new TextEncoder).encode(r), t => t.toString(16).padStart(2, "0")).join("").toUpperCase() }; export { at as createSingTx };
    // グローバルスコープでアクセス可能にする
    window.SymbolSignTx = { createSingTx: at };
  </script>
  <!-- スタイルは必要に応じてここに追加 -->
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f8f9fa;
      color: #333;
      line-height: 1.6;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 90vh;
    }

    h1 {
      color: #5200c6;
      margin-bottom: 20px;
    }

    .container {
      background-color: white;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      padding: 30px;
      max-width: 500px;
      width: 100%;
      text-align: center;
    }

    p {
      margin: 10px 0;
    }

    .auth-button {
      padding: 12px 25px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      background-color: #5200c6;
      color: white;
      cursor: pointer;
      margin-top: 20px;
      transition: all 0.3s ease;
    }

    .auth-button:hover {
      background-color: #6e00ff;
      transform: translateY(-2px);
    }

    .auth-button:disabled {
      background-color: #9370DB;
      cursor: not-allowed;
      opacity: 0.7;
    }

    .error-message {
      color: #a94442;
      background-color: #f2dede;
      border: 1px solid #ebccd1;
      padding: 15px;
      border-radius: 4px;
      margin: 20px 0;
      display: none;
    }

    .success-message {
      color: #3c763d;
      background-color: #dff0d8;
      border: 1px solid #d6e9c6;
      padding: 15px;
      border-radius: 4px;
      margin: 20px 0;
      display: none;
    }

    .status {
      margin-top: 20px;
      font-style: italic;
      color: #666;
    }

    @media (max-width: 600px) {
      .container {
        padding: 20px;
        max-width: 90%;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Symbol Sign On</h1>
    <div id="auth-details">
      <p>Client ID: <span id="client-id"></span></p>
      <p>Redirect URI: <span id="redirect-uri"></span></p>
    </div>

    <div id="error-message" class="error-message"></div>
    <div id="success-message" class="success-message"></div>

    <div id="auth-controls">
      <button id="symbol-auth-btn" class="auth-button">Symbolで認証</button>
      <div id="status" class="status"></div>
    </div>
  </div>

  <script>
    // URLパラメータから値を取得
    const urlParams = new URLSearchParams(window.location.search);
    const clientId = urlParams.get('client_id');
    const redirectUri = urlParams.get('redirect_uri');

    // URLから認可コードを確認（リダイレクトで戻ってきた場合）
    const code = urlParams.get('code');
    if (code) {
      console.log('認可コードを検出しました:', code);
      // 既に認可コードが取得できている場合は成功メッセージを表示
      document.addEventListener('DOMContentLoaded', function() {
        showSuccess('認証成功！認可コード：' + code);
        document.getElementById('symbol-auth-btn').style.display = 'none';
        document.getElementById('status').textContent = '既に認証されています';
      });
    }

    // HTMLに値を表示
    document.getElementById('client-id').textContent = clientId || '未指定';
    document.getElementById('redirect-uri').textContent = redirectUri || '未指定';

    // エラーを表示する関数
    function showError(message) {
      const errorElement = document.getElementById('error-message');
      errorElement.textContent = message;
      errorElement.style.display = 'block';

      // ステータス表示をクリア
      document.getElementById('status').textContent = '';
    }

    // 成功メッセージを表示する関数
    function showSuccess(message) {
      const successElement = document.getElementById('success-message');
      successElement.textContent = message;
      successElement.style.display = 'block';

      // エラーメッセージがあれば非表示にする
      document.getElementById('error-message').style.display = 'none';
    }

    // ステータスメッセージを表示する関数
    function showStatus(message) {
      document.getElementById('status').textContent = message;
    }

    // エラーを親ウィンドウに通知する関数
    function notifyParentAndClose(error, description) {
      // ローカルにもエラーを表示
      showError(`${error}: ${description}`);

      if (window.opener && !window.opener.closed) {
        // 親ウィンドウにエラーメッセージを送信
        window.opener.postMessage({
          type: 'login_error',
          error: error,
          errorDescription: description
        }, '*');

        // 少し待ってからポップアップを閉じる
        setTimeout(() => {
          window.close();
        }, 2000);
      }
    }

    // /oauth/authorize からチャレンジ取得
    if (clientId && redirectUri) {
      fetch(`/oauth/authorize?response_type=code&client_id=${encodeURIComponent(clientId)}&redirect_uri=${encodeURIComponent(redirectUri)}`)
        .then(response => response.json())
        .then(data => {
          if (data.error) {
            // エラーを親ウィンドウに通知してポップアップを閉じる
            notifyParentAndClose(data.error, data.error_description);
          } else {
            // チャレンジを表示（例: コンソールに出力）
            console.log('チャレンジ:', data.challenge);
            // チャレンジをグローバル変数に保存して後で使えるようにする
            window.challengeCode = data.challenge;
          }
        })
        .catch(error => {
          console.error('チャレンジ取得エラー:', error);
          // システムエラーを親ウィンドウに通知してポップアップを閉じる
          notifyParentAndClose('system_error', 'サーバーとの通信に失敗しました');
        });
    }

    // Symbolで認証ボタンのクリックイベント
    document.getElementById('symbol-auth-btn').addEventListener('click', function () {
      authenticateWithSymbol();
    });

    // デバイス判定
    function isMobileDevice() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    // Symbolでの認証処理
    function authenticateWithSymbol() {
      // ここにSymbol認証の処理を実装
      console.log('Symbol認証が開始されました');

      // チャレンジコードが空の場合は画面を閉じエラーを表示
      if (!window.challengeCode) {
        notifyParentAndClose('challenge_error', 'Failed to retrieve the challenge code.');
        return;
      }

      // トランザクションの作成
      const challengeValue = window.challengeCode;
      console.log('Challenge ID:', challengeValue);
      const signTx = SymbolSignTx.createSingTx(152, '\0' + challengeValue);

      // デバイス判定
      const deviceType = isMobileDevice() ? 'スマートフォン' : 'PC';
      if (isMobileDevice()) {
        // スマートフォンの場合はaLiceをリクエスト
        console.log('スマートフォンを検出しました。aLiceをリクエストします。');
      } else {
        // PCの場合はSSSモジュールをリクエスト
        console.log('PC detected. Requesting SSS.');
        if (SSSModule.requestSSS()) {
          SSSModule.setTransactionByPayload(signTx);
          SSSModule.requestSign().then((signedTx) => {
            console.log('署名されたトランザクション:', signedTx.payload);
            // 署名検証エンドポイントにデータを送信
            submitSignatureForVerification(signedTx.payload);
          }).catch((error) => {
            console.error('署名エラー:', error);
            showError('署名に失敗しました: ' + error.message);
          });
        }
      }
    }

    // 署名検証のためのデータ送信関数
    function submitSignatureForVerification(signedTransaction) {
      const verificationData = {
        payload: signedTransaction
      };
      console.log('署名検証のためのデータ:', verificationData);

      // ボタンを無効化して処理中であることを表示
      const authBtn = document.getElementById('symbol-auth-btn');
      authBtn.disabled = true;
      authBtn.textContent = '検証中...';

      // ポップアップかどうかを確認
      const isPopup = urlParams.get('popup') === 'true' || urlParams.get('display') === 'popup';

      // x-requested-with ヘッダーを追加してポップアップであることを伝える
      const headers = {
        'Content-Type': 'application/json'
      };

      if (isPopup) {
        headers['x-requested-with'] = 'popup';
      }

      fetch('/oauth/verify-signature', {
        method: 'PUT',
        headers: headers,
        body: JSON.stringify(verificationData)
      })
        .then(response => {
          console.log('署名検証のレスポンス:', response);

          // レスポンスが成功（200-299）でない場合はエラーを投げる
          if (!response.ok) {
            return response.json().then(errorData => {
              throw new Error(errorData.error || '検証に失敗しました');
            });
          }

          // HTMLレスポンスの場合（ポップアップ向け）
          if (response.headers.get('content-type')?.includes('text/html')) {
            // レスポンスがHTMLの場合、内容を取得して現在のページに適用する
            return response.text().then(html => {
              document.open();
              document.write(html);
              document.close();
              // 処理完了を示すためにtrueを返す
              return true;
            });
          }

          // JSON形式のレスポンスを期待
          return response.json();
        })
        .then(data => {
          // dataがtrueの場合は既にHTMLを処理済みなので何もしない
          if (data === true) return;

          console.log('署名検証成功:', data);

          // 認証コードを取得
          const code = data.code;
          if (!code) {
            throw new Error('認証コードが見つかりません');
          }

          // リダイレクト処理
          if (redirectUri) {
            const redirectUrl = new URL(redirectUri);

            // ここで認可コードをクエリパラメータとして追加
            redirectUrl.searchParams.set('code', code);

            // URLにstate（状態）パラメータがあれば、それも引き継ぐ
            const state = urlParams.get('state');
            if (state) {
              redirectUrl.searchParams.set('state', state);
            }

            console.log('認証コード取得成功：', code);
            console.log('リダイレクト先完全URL：', redirectUrl.toString());

            // ポップアップの場合は親ウィンドウにメッセージを送信
            if (isPopup && window.opener) {
              // ポップアップの場合はpostMessageで親ウィンドウに通知
              window.opener.postMessage({
                type: 'oauth_success',
                code: code,
                redirect_uri: redirectUri,
                state: state
              }, '*');

              // メッセージを表示して少し待ってからポップアップを閉じる
              const successMessage = document.createElement('div');
              successMessage.style.padding = '20px';
              successMessage.style.background = '#dff0d8';
              successMessage.style.color = '#3c763d';
              successMessage.style.borderRadius = '5px';
              successMessage.style.margin = '20px 0';
              successMessage.textContent = '認証に成功しました。ウィンドウを閉じています...';

              document.body.innerHTML = '';
              document.body.appendChild(successMessage);

              setTimeout(() => {
                window.close();
              }, 1000);
            } else {
              // 通常のリダイレクトの場合
              // 成功メッセージを表示
              showSuccess('認証に成功しました。リダイレクトします...');

              // リダイレクト先のURLを確認
              const finalUrl = redirectUrl.toString();
              console.log('最終リダイレクト先：', finalUrl);

              // リダイレクトはGETメソッドで行う
              // タイミングの問題を防ぐため、少し遅延させる
              setTimeout(() => {
                // window.location.replace()を使うとブラウザの履歴に残らないため、
                // ブラウザの「戻る」ボタンでの問題を防げる
                window.location.replace(finalUrl);
              }, 1000);
            }
          }
        })
        .catch(error => {
          console.error('検証エラー:', error);

          // ボタンを元に戻す
          authBtn.disabled = false;
          authBtn.textContent = 'Symbolで認証';

          // エラーメッセージの表示
          const errorMessage = document.createElement('div');
          errorMessage.style.padding = '10px';
          errorMessage.style.background = '#f2dede';
          errorMessage.style.color = '#a94442';
          errorMessage.style.borderRadius = '5px';
          errorMessage.style.margin = '10px 0';
          errorMessage.textContent = `エラー: ${error.message || '検証に失敗しました'}`;

          document.body.insertBefore(errorMessage, authBtn.parentNode.nextSibling);

          // ポップアップの場合は親ウィンドウにエラーを通知
          if (isPopup && window.opener) {
            notifyParentAndClose('verification_error', error.message || '検証に失敗しました');
          }
        });
    }

  </script>
</body>

</html>
