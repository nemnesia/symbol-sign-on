<!--
RFC 草案: Symbol Sign-On
ステータス: Draft
作成日: 2026-01-17
-->

# RFC 0001 — Symbol Sign-On (Draft)

**ステータス:** Draft

**作成者:** ccHarvestasya

**目次**

- 概要
- 背景と目的
- 仕様
  - 識別子モデル
  - 認証フロー
- セキュリティ考慮事項
- プライバシー考慮事項
- 実装上の注意点
- 例

## 概要

Symbol のアドレスを DID 風の識別子（`did:symbol:<master-account-address>`）として扱い、サーバが発行するチャレンジに対するオフチェーン署名を用いて認証する方式を定義します。必要に応じてオンチェーンの有効鍵・更新履歴を参照し、鍵ローテーションや失効に追随します。

## 未解決の課題

（現時点では未解決項目なし。追加の論点が出た場合はここに追記する。）

## 背景と目的

従来のパスワード中心の認証は管理負担と漏洩リスクが高く、DID の理念は有望であるが実運用は複雑になりがちです。本設計はスマートコントラクトを使わず、ブロックチェーン上の公開情報（有効鍵・更新履歴）を参照しながら、UX と安全性のバランスを取ることを目的とします。

## 仕様

この節は実装者向けの最低限のルールを定義します。より詳細なメッセージフォーマット（署名対象の正規形）は別仕様で規定します。

- メッセージフォーマット（Draft）: `docs/specs/auth-message-format.md`

### 識別子モデル

- DID 代替表現: `did:symbol:<master-account-address>` を識別子とする。
- マスターアカウントはキー管理（ローテーション・失効ログ）の唯一の公的参照点とする。

### 認証フロー

本仕様は設計方針としてチェーンへのトランザクション発行を極力避け、オフチェーン署名フローを推奨します。

- オフチェーン署名フロー（チャレンジ + 署名）
  - サーバはチャレンジ（nonce + タイムスタンプ + サーバ識別子）を発行します。
  - クライアントはチャレンジに対して署名を行い、署名データをサーバに返します。
  - サーバは署名を検証し、必要に応じてオンチェーンの有効鍵情報を参照して認証可否を決定します。

### API インデックス（索引）

この RFC では API の詳細スキーマは別ファイルで定義することを想定します。ここでは実装間合意のための最小限のエンドポイント一覧と目的を示します。

- `POST /auth/challenge`
  - 目的: サーバが一時的なチャレンジ（`nonce`, `expires_at`, `server_id`）を発行する。
  - レスポンス（例）: `{ "nonce": "...", "expires_at": "2026-01-17T12:34:56Z", "server_id": "auth.example" }`

- `POST /auth/verify`
  - 目的: クライアントが署名を送信して認証を要求する。
  - リクエスト（例）: `{ "did": "did:symbol:...", "nonce": "...", "signature": "base64", "meta": { /* optional */ } }`
  - レスポンス（例）: `{ "status": "ok", "access_token": "<JWT>", "expires_in": 3600 }` または `{ "status": "error", "reason": "..." }`

- `GET /keys/{did}/status`（オプション）
  - 目的: サーバがオンチェーンの有効鍵情報（ローテーション・失効）を確認するための参照用エンドポイント。RFC ではオプション扱いとし、詳細は実装仕様に委ねる。

- `GET /health`
  - 目的: サービスの簡易ヘルスチェック（HTTP 200 を返せば正常）。依存先（DB/RPC）の簡易状態を返すことを推奨。認証不要。

- `POST /auth/refresh`
  - 目的: `refresh_token` により新しい `access_token` を取得する。リフレッシュ回数や有効期間は実装ポリシーとする。
  - リクエスト（例）: `{ "refresh_token": "..." }`
  - レスポンス（例）: `{ "status": "ok", "access_token": "<JWT>", "expires_in": 3600 }`

- `POST /auth/revoke`
  - 目的: 発行済トークン（refresh／access）やセッションを取り消す（ログアウト、鍵ローテーション時に利用）。
  - リクエスト（例）: `{ "token": "...", "reason": "user_logout" }`

- `GET /users/{did}`
  - 目的: DID に紐づく公開プロフィールを返す（`did`, `displayName`, `roles`, `lastKeyRotation` 等）。`access_token` を要求する。
  - レスポンス（例）: `{ "did": "did:symbol:...", "displayName": "Alice", "roles": ["user"], "lastKeyRotation": "2026-01-01T00:00:00Z" }`

設計上の注意:

- 署名対象には常に `nonce + server_id + timestamp` を含めること。
- 署名対象メッセージ（正規形）の詳細は `docs/specs/auth-message-format.md` に従うこと。
- `POST /auth/verify` では受信した署名の一意性をサーバで記録し、再利用を拒否すること。
- ペイロードの厳密なスキーマ（型、エラーコード、HTTP レスポンス詳細）は `docs/specs/auth-api.yaml` のような別ファイル（OpenAPI）で定義してください。

## セキュリティ考慮事項

- オフチェーン署名フローでは、サーバ発行のチャレンジ（nonce と有効期限）を必ず検証し、受信した署名の再利用を防止するために署名受領の記録（署名の一意性検査）を行います。
- 署名されたメッセージの正当性を確認する際、必要に応じてオンチェーンの有効鍵・更新履歴を参照して当該署名鍵が失効していないことを確認してください。
- チャレンジの有効期限は短く設定し、サーバ側のリプレイ検出ログはアクセス制御と監査を適用してください。

### ログ保持と監査（推奨初期値）

- 署名受領ログの保持期間と監査ポリシーは運用で調整可能にしてください。
  - 保存期間（初期推奨、運用で調整）:
    - リプレイ防止用（nonce／signature_hash）：短期 — **7日**
    - 認証監査ログ（認可／トークン発行記録）：中期 — **90日**
    - インシデント証跡（調査用の完全ログ）：必要に応じて長期アーカイブ — **365日**（アクセス制限・別格扱い）
    - すべて可変にしてポリシーで管理すること

- トークン運用の初期推奨値（参考）:
  - チャレンジ（nonce）有効期限: **5分**（300 秒）。署名はこの期限内に行われることを期待します。
  - `access_token`（短期 JWT）有効期限: **15分**（900 秒）を推奨。
  - `refresh_token`（長期）: スライディング方式で **アイドル期限=7日、絶対期限=90日** を初期値の目安とする。
  - これらは RFC の初期推奨であり、実装では可変パラメータとして運用できるようにしてください。

  また、`refresh_token` ローテーション（rotation）を実装し、使い回しが検出された場合は当該セッションおよび関連セッションを無効化する運用を推奨します。

## プライバシー考慮事項

- 本設計は公開チェーンへのトランザクション送信を原則想定しません。公開チェーンに情報を書き込むと行動の痕跡が残るため、オフチェーン署名フローを採用することで利用者のプライバシーを確保します。

## 実装上の注意点

- サーバはオンチェーン参照が必要な場合、複数のノード／プロバイダ（RPC）を参照して有効鍵情報や更新履歴を確認することを推奨します。
- 署名の一意性チェックはサーバ側で受領記録を用いて排他制御により実装してください。ログの TTL や削除ポリシーを運用で定めてください。

### オンチェーン参照の頻度とキャッシュ方針（推奨）

- 推奨: 可能であれば **毎回オンチェーン参照** を行う運用を推奨します。多くの RPC 実装は DID に紐づく公開鍵やメタデータを単一リクエストで取得できるため、毎回のフェッチで最新性を保証しつつ実用的な遅延に収まる場合があります。
- フォールバック（RPC 性能やコスト制約がある場合）: キャッシュ TTL = **5 分** を初期値の目安とし、キャッシュ項目に `publicKey`, `fetchedAt`, `expiresAt`, `sourceBlockHeight` を含めること。
- 重要操作（鍵ローテーション、権限昇格など）は即時オンチェーン確認を強制するポリシーを設けてください。
- 可能であればイベント駆動（インデクサ / webhook）でキャッシュを即時無効化する方式を併用することを推奨します。
- フェールセーフ: RPC が利用不可のときの挙動（既知キャッシュを使うか拒否するか）を明確化し、監査ログに参照時刻と参照方法（cache/hit/miss / blockHeight）を残してください。

## 例

- 簡易シーケンス図（概念）:

  Client -> Server: request challenge
  Server -> Client: nonce
  Client -> Server: signature(nonce)
  Server -> verify signature and (optionally) check on-chain key state

## 参考文献

- Symbol documentation
- DID Core (W3C)

---

**注:** これは草案です。具体的な API 仕様やメッセージフォーマットは別 RFC/仕様で定義してください。
