{"version":3,"file":"symbol-sign-tx.mjs","sources":["../node_modules/@noble/hashes/esm/utils.js","../node_modules/@noble/hashes/esm/_md.js","../node_modules/@noble/hashes/esm/legacy.js","../node_modules/@noble/hashes/esm/_u64.js","../node_modules/@noble/hashes/esm/sha3.js","../../src/convert.ts","../../src/address.ts","../../src/index.ts"],"sourcesContent":["/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nexport function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nexport function abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nexport function ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nexport function byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nexport const byteSwapIfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexport const swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nexport class Hash {\n}\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport const wrapConstructor = createHasher;\nexport const wrapConstructorWithOpts = createOptHasher;\nexport const wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return Uint8Array.from(crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { Hash, abytes, aexists, aoutput, clean, createView, toBytes } from \"./utils.js\";\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nexport function Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        clean(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map","/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */\nimport { Chi, HashMD, Maj } from \"./_md.js\";\nimport { clean, createHasher, rotl } from \"./utils.js\";\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n/** SHA1 legacy hash class. */\nexport class SHA1 extends HashMD {\n    constructor() {\n        super(64, 20, 8, false);\n        this.A = SHA1_IV[0] | 0;\n        this.B = SHA1_IV[1] | 0;\n        this.C = SHA1_IV[2] | 0;\n        this.D = SHA1_IV[3] | 0;\n        this.E = SHA1_IV[4] | 0;\n    }\n    get() {\n        const { A, B, C, D, E } = this;\n        return [A, B, C, D, E];\n    }\n    set(A, B, C, D, E) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA1_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 80; i++)\n            SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n        // Compression function main loop, 80 rounds\n        let { A, B, C, D, E } = this;\n        for (let i = 0; i < 80; i++) {\n            let F, K;\n            if (i < 20) {\n                F = Chi(B, C, D);\n                K = 0x5a827999;\n            }\n            else if (i < 40) {\n                F = B ^ C ^ D;\n                K = 0x6ed9eba1;\n            }\n            else if (i < 60) {\n                F = Maj(B, C, D);\n                K = 0x8f1bbcdc;\n            }\n            else {\n                F = B ^ C ^ D;\n                K = 0xca62c1d6;\n            }\n            const T = (rotl(A, 5) + F + E + K + SHA1_W[i]) | 0;\n            E = D;\n            D = C;\n            C = rotl(B, 30);\n            B = A;\n            A = T;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        this.set(A, B, C, D, E);\n    }\n    roundClean() {\n        clean(SHA1_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexport const sha1 = /* @__PURE__ */ createHasher(() => new SHA1());\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */\nexport class MD5 extends HashMD {\n    constructor() {\n        super(64, 16, 8, true);\n        this.A = MD5_IV[0] | 0;\n        this.B = MD5_IV[1] | 0;\n        this.C = MD5_IV[2] | 0;\n        this.D = MD5_IV[3] | 0;\n    }\n    get() {\n        const { A, B, C, D } = this;\n        return [A, B, C, D];\n    }\n    set(A, B, C, D) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            MD5_W[i] = view.getUint32(offset, true);\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D } = this;\n        for (let i = 0; i < 64; i++) {\n            let F, g, s;\n            if (i < 16) {\n                F = Chi(B, C, D);\n                g = i;\n                s = [7, 12, 17, 22];\n            }\n            else if (i < 32) {\n                F = Chi(D, B, C);\n                g = (5 * i + 1) % 16;\n                s = [5, 9, 14, 20];\n            }\n            else if (i < 48) {\n                F = B ^ C ^ D;\n                g = (3 * i + 5) % 16;\n                s = [4, 11, 16, 23];\n            }\n            else {\n                F = C ^ (B | ~D);\n                g = (7 * i) % 16;\n                s = [6, 10, 15, 21];\n            }\n            F = F + A + K[i] + MD5_W[g];\n            A = D;\n            D = C;\n            C = B;\n            B = B + rotl(F, s[i % 4]);\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        this.set(A, B, C, D);\n    }\n    roundClean() {\n        clean(MD5_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nexport const md5 = /* @__PURE__ */ createHasher(() => new MD5());\n// RIPEMD-160\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n    const L = [Id160];\n    const R = [Pi160];\n    const res = [L, R];\n    for (let i = 0; i < 4; i++)\n        for (let j of res)\n            j.push(j[i].map((k) => Rho160[k]));\n    return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\nconst shifts160 = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction ripemd_f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    if (group === 1)\n        return (x & y) | (~x & z);\n    if (group === 2)\n        return (x | ~y) ^ z;\n    if (group === 3)\n        return (x & z) | (y & ~z);\n    return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends HashMD {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF_160[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        clean(BUF_160);\n    }\n    destroy() {\n        this.destroyed = true;\n        clean(this.buffer);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nexport const ripemd160 = /* @__PURE__ */ createHasher(() => new RIPEMD160());\n//# sourceMappingURL=legacy.js.map","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from \"./_u64.js\";\n// prettier-ignore\nimport { abytes, aexists, anumber, aoutput, clean, createHasher, createXOFer, Hash, swap32IfBE, toBytes, u32 } from \"./utils.js\";\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst IOTAS = split(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nexport function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    clean(B);\n}\n/** Keccak sponge function. */\nexport class Keccak extends Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        this.enableXOF = false;\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        // Can be passed from user as dkLen\n        anumber(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        // 0 < blockLen < 200\n        if (!(0 < blockLen && blockLen < 200))\n            throw new Error('only keccak-f1600 function is supported');\n        this.state = new Uint8Array(200);\n        this.state32 = u32(this.state);\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    keccak() {\n        swap32IfBE(this.state32);\n        keccakP(this.state32, this.rounds);\n        swap32IfBE(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        const { blockLen, state } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        aexists(this, false);\n        abytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        anumber(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        aoutput(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        clean(this.state);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => createHasher(() => new Keccak(blockLen, suffix, outputLen));\n/** SHA3-224 hash function. */\nexport const sha3_224 = /* @__PURE__ */ (() => gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */\nexport const sha3_256 = /* @__PURE__ */ (() => gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */\nexport const sha3_384 = /* @__PURE__ */ (() => gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */\nexport const sha3_512 = /* @__PURE__ */ (() => gen(0x06, 72, 512 / 8))();\n/** keccak-224 hash function. */\nexport const keccak_224 = /* @__PURE__ */ (() => gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */\nexport const keccak_256 = /* @__PURE__ */ (() => gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */\nexport const keccak_384 = /* @__PURE__ */ (() => gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */\nexport const keccak_512 = /* @__PURE__ */ (() => gen(0x01, 72, 512 / 8))();\nconst genShake = (suffix, blockLen, outputLen) => createXOFer((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\n/** SHAKE128 XOF with 128-bit security. */\nexport const shake128 = /* @__PURE__ */ (() => genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */\nexport const shake256 = /* @__PURE__ */ (() => genShake(0x1f, 136, 256 / 8))();\n//# sourceMappingURL=sha3.js.map","/**\n * 16進文字列をUint8Arrayに変換\n */\nexport const hexToUint8 = (hex: string): Uint8Array => {\n  if (hex.length === 0) return new Uint8Array()\n  return new Uint8Array(hex.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16)))\n}\n\n/**\n * Uint8Arrayを16進文字列に変換\n */\nexport const uint8ToHex = (bytes: Uint8Array): string =>\n  Array.from(bytes, (b) => b.toString(16).padStart(2, '0')).join('')\n","import { ripemd160 } from '@noble/hashes/legacy'\nimport { sha3_256 } from '@noble/hashes/sha3'\nimport { hexToUint8, uint8ToHex } from './convert.js'\n\n/**\n * Base32エンコード/デコード用の文字セット\n */\nconst BASE32_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'\n\n/**\n * HEXアドレスをBase32アドレスに変換\n */\nexport const hexToBase32Address = (hexAddress: string): string => {\n  let bits = 0\n  let value = 0\n  let base32 = ''\n  for (const byte of hexToUint8(hexAddress)) {\n    value = (value << 8) | byte\n    bits += 8\n    while (bits >= 5) {\n      base32 += BASE32_CHARS[(value >>> (bits - 5)) & 0x1f]\n      bits -= 5\n    }\n  }\n  if (bits > 0) base32 += BASE32_CHARS[(value << (5 - bits)) & 0x1f]\n  return base32\n}\n\n/**\n * Base32アドレスをHEXアドレスに変換\n */\nexport const base32ToHexAddress = (base32Address: string): string => {\n  let bits = 0\n  let value = 0\n  let hex = ''\n  for (const char of base32Address) {\n    value = (value << 5) | BASE32_CHARS.indexOf(char)\n    bits += 5\n    while (bits >= 8) {\n      hex += ((value >>> (bits - 8)) & 0xff).toString(16).padStart(2, '0')\n      bits -= 8\n    }\n  }\n  return hex.toUpperCase()\n}\n\n/**\n * 公開鍵からアドレスを生成\n */\nexport const publicKeyToAddress = (\n  networkId: number,\n  publicKey: string,\n): string => {\n  const ripemdHash = ripemd160(sha3_256(hexToUint8(publicKey)))\n  const versionPrefixed = new Uint8Array([networkId, ...ripemdHash])\n  const checksum = sha3_256(versionPrefixed).slice(0, 3)\n  return hexToBase32Address(\n    uint8ToHex(new Uint8Array([...versionPrefixed, ...checksum])),\n  )\n}\n","import { base32ToHexAddress, publicKeyToAddress } from './address'\n\nexport const createSignTx = (networkNumber: number, message: string) => {\n  const len = 160 + message.length\n  const sizeHex = len.toString(16).padStart(8, '0').toUpperCase()\n  const size = sizeHex.match(/.{2}/g)?.reverse().join('')\n\n  const verifiableEntityHeaderReserved_1 = '00000000'\n  const signature =\n    '00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'\n  const signerPublicKey =\n    '0000000000000000000000000000000000000000000000000000000000000000'\n  const entityBodyReserved_1 = '00000000'\n  const version = '01'\n  const network = networkNumber.toString(16).padStart(2, '0').toUpperCase()\n  const type = '5441'\n  const fee = '0000000000000000'\n  const deadline = '0000000000000000'\n\n  const recipientAddress = base32ToHexAddress(\n    publicKeyToAddress(networkNumber, signerPublicKey),\n  )\n\n  const mosaicsCount = '00'\n  const transferTransactionBodyReserved_1 = '00'\n  const transferTransactionBodyReserved_2 = '00000000'\n\n  const encodedMessage = new TextEncoder().encode(message)\n  const messageSizeHex = encodedMessage.length\n    .toString(16)\n    .padStart(4, '0')\n    .toUpperCase()\n  const messageSize = messageSizeHex.match(/.{2}/g)!.reverse().join('')\n  const messageHex = Array.from(encodedMessage, (byte) =>\n    byte.toString(16).padStart(2, '0'),\n  )\n    .join('')\n    .toUpperCase()\n\n  // 全体を結合\n  const transaction =\n    size +\n    verifiableEntityHeaderReserved_1 +\n    signature +\n    signerPublicKey +\n    entityBodyReserved_1 +\n    version +\n    network +\n    type +\n    fee +\n    deadline +\n    recipientAddress +\n    messageSize +\n    transferTransactionBodyReserved_1 +\n    transferTransactionBodyReserved_2 +\n    mosaicsCount +\n    messageHex\n\n  return transaction\n}\n"],"names":["isBytes","a","Uint8Array","ArrayBuffer","isView","constructor","name","anumber","n","Number","isSafeInteger","Error","abytes","b","lengths","length","includes","aexists","instance","checkFinished","destroyed","finished","aoutput","out","min","outputLen","u32","arr","Uint32Array","buffer","byteOffset","Math","floor","byteLength","clean","arrays","i","fill","createView","DataView","rotl","word","shift","byteSwap","byteSwap32","swap32IfBE","u","utf8ToBytes","str","TextEncoder","encode","toBytes","data","Hash","createHasher","hashCons","hashC","msg","update","digest","tmp","blockLen","create","setBigUint64","view","value","isLE","_32n","BigInt","_u32_max","wh","wl","h","l","setUint32","HashMD","padOffset","super","this","pos","len","take","dataView","process","set","subarray","roundClean","digestInto","oview","outLen","state","get","res","slice","destroy","_cloneInto","to","clone","Rho160","from","Id160","Array","map","_","Pi160","idxLR","j","push","k","idxL","idxR","shifts160","shiftsL160","idx","shiftsR160","Kl160","Kr160","ripemd_f","group","x","y","z","BUF_160","RIPEMD160","h0","h1","h2","h3","h4","offset","getUint32","al","ar","bl","br","cl","cr","dl","dr","el","er","rGroup","hbl","hbr","rl","rr","sl","sr","tl","tr","ripemd160","U32_MASK64","fromBig","le","split","lst","Ah","Al","rotlSH","s","rotlSL","rotlBH","rotlBL","_0n","_1n","_2n","_7n","_256n","_0x71n","SHA3_PI","SHA3_ROTL","_SHA3_IOTA","round","R","t","IOTAS","SHA3_IOTA_H","SHA3_IOTA_L","rotlH","rotlL","keccakP","rounds","B","idx1","idx0","B0","B1","Th","Tl","curH","curL","PI","Keccak","suffix","enableXOF","posOut","state32","keccak","finish","writeInto","bufferOut","xofInto","xof","bytes","gen","sha3_256","hexToUint8","hex","match","byte","parseInt","uint8ToHex","toString","padStart","join","BASE32_CHARS","hexToBase32Address","hexAddress","bits","base32","base32ToHexAddress","base32Address","char","indexOf","toUpperCase","publicKeyToAddress","networkId","publicKey","ripemdHash","versionPrefixed","checksum","createSignTx","networkNumber","message","sizeHex","size","reverse","verifiableEntityHeaderReserved_1","signature","signerPublicKey","entityBodyReserved_1","version","network","type","fee","deadline","recipientAddress","mosaicsCount","transferTransactionBodyReserved_1","transferTransactionBodyReserved_2","encodedMessage"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}