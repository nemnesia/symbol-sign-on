{"version":3,"file":"symbol-sign-on.mjs","sources":["../../src/challenge.ts","../node_modules/@noble/hashes/esm/utils.js","../node_modules/@noble/hashes/esm/_md.js","../node_modules/@noble/hashes/esm/legacy.js","../node_modules/@noble/hashes/esm/_u64.js","../node_modules/@noble/hashes/esm/sha3.js","../../src/utils/convert.ts","../../src/utils/address.ts","../../src/transaction.ts","../../src/utils/platformUtils.ts"],"sourcesContent":["/**\n * チャレンジリクエストの型定義\n */\nexport type ChallengeRequest = {\n  client_id: string\n  redirect_uri: string\n}\n\n/**\n * チャレンジレスポンスの型定義\n */\nexport type ChallengeResponse = {\n  client_id: string\n  redirect_uri: string\n  challenge: string\n}\n\n/**\n * チャレンジエラーの型定義\n */\nexport type ChallengeError = {\n  error: string\n  error_description?: string\n}\n\n/**\n * チャレンジを取得する\n * @param params パラメータ(client_id, redirect_uri)\n * @param baseUrl サーバベースURL\n * @returns チャレンジレスポンスまたはエラー\n */\nexport const getChallenge = async (\n  params: ChallengeRequest,\n  baseUrl?: string,\n): Promise<ChallengeResponse | ChallengeError> => {\n  const urlParams = new URLSearchParams({\n    response_type: 'code',\n    client_id: params.client_id,\n    redirect_uri: params.redirect_uri,\n  })\n  const res = await fetch(`${baseUrl}/oauth/authorize?${urlParams.toString()}`)\n  const data = await res.json()\n  return data\n}\n\n/**\n * 署名検証を行う\n * @param signedTx 署名済みトランザクション\n * @param baseUrl サーバベースURL\n */\nexport const verifySignature = async (signedTx: string, baseUrl?: string) => {\n  const form = document.createElement('form')\n  form.method = 'POST'\n  form.action = `${baseUrl}/oauth/verify-signature`\n  form.style.display = 'none'\n\n  const payloadInput = document.createElement('input')\n  payloadInput.type = 'hidden'\n  payloadInput.name = 'payload'\n  payloadInput.value = signedTx\n\n  form.appendChild(payloadInput)\n  document.body.appendChild(form)\n\n  form.submit()\n}\n","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nexport function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nexport function abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nexport function ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nexport function byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nexport const byteSwapIfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexport const swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nexport class Hash {\n}\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport const wrapConstructor = createHasher;\nexport const wrapConstructorWithOpts = createOptHasher;\nexport const wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return Uint8Array.from(crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { Hash, abytes, aexists, aoutput, clean, createView, toBytes } from \"./utils.js\";\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nexport function Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        clean(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map","/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */\nimport { Chi, HashMD, Maj } from \"./_md.js\";\nimport { clean, createHasher, rotl } from \"./utils.js\";\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n/** SHA1 legacy hash class. */\nexport class SHA1 extends HashMD {\n    constructor() {\n        super(64, 20, 8, false);\n        this.A = SHA1_IV[0] | 0;\n        this.B = SHA1_IV[1] | 0;\n        this.C = SHA1_IV[2] | 0;\n        this.D = SHA1_IV[3] | 0;\n        this.E = SHA1_IV[4] | 0;\n    }\n    get() {\n        const { A, B, C, D, E } = this;\n        return [A, B, C, D, E];\n    }\n    set(A, B, C, D, E) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA1_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 80; i++)\n            SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n        // Compression function main loop, 80 rounds\n        let { A, B, C, D, E } = this;\n        for (let i = 0; i < 80; i++) {\n            let F, K;\n            if (i < 20) {\n                F = Chi(B, C, D);\n                K = 0x5a827999;\n            }\n            else if (i < 40) {\n                F = B ^ C ^ D;\n                K = 0x6ed9eba1;\n            }\n            else if (i < 60) {\n                F = Maj(B, C, D);\n                K = 0x8f1bbcdc;\n            }\n            else {\n                F = B ^ C ^ D;\n                K = 0xca62c1d6;\n            }\n            const T = (rotl(A, 5) + F + E + K + SHA1_W[i]) | 0;\n            E = D;\n            D = C;\n            C = rotl(B, 30);\n            B = A;\n            A = T;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        this.set(A, B, C, D, E);\n    }\n    roundClean() {\n        clean(SHA1_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexport const sha1 = /* @__PURE__ */ createHasher(() => new SHA1());\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */\nexport class MD5 extends HashMD {\n    constructor() {\n        super(64, 16, 8, true);\n        this.A = MD5_IV[0] | 0;\n        this.B = MD5_IV[1] | 0;\n        this.C = MD5_IV[2] | 0;\n        this.D = MD5_IV[3] | 0;\n    }\n    get() {\n        const { A, B, C, D } = this;\n        return [A, B, C, D];\n    }\n    set(A, B, C, D) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            MD5_W[i] = view.getUint32(offset, true);\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D } = this;\n        for (let i = 0; i < 64; i++) {\n            let F, g, s;\n            if (i < 16) {\n                F = Chi(B, C, D);\n                g = i;\n                s = [7, 12, 17, 22];\n            }\n            else if (i < 32) {\n                F = Chi(D, B, C);\n                g = (5 * i + 1) % 16;\n                s = [5, 9, 14, 20];\n            }\n            else if (i < 48) {\n                F = B ^ C ^ D;\n                g = (3 * i + 5) % 16;\n                s = [4, 11, 16, 23];\n            }\n            else {\n                F = C ^ (B | ~D);\n                g = (7 * i) % 16;\n                s = [6, 10, 15, 21];\n            }\n            F = F + A + K[i] + MD5_W[g];\n            A = D;\n            D = C;\n            C = B;\n            B = B + rotl(F, s[i % 4]);\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        this.set(A, B, C, D);\n    }\n    roundClean() {\n        clean(MD5_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nexport const md5 = /* @__PURE__ */ createHasher(() => new MD5());\n// RIPEMD-160\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n    const L = [Id160];\n    const R = [Pi160];\n    const res = [L, R];\n    for (let i = 0; i < 4; i++)\n        for (let j of res)\n            j.push(j[i].map((k) => Rho160[k]));\n    return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\nconst shifts160 = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction ripemd_f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    if (group === 1)\n        return (x & y) | (~x & z);\n    if (group === 2)\n        return (x | ~y) ^ z;\n    if (group === 3)\n        return (x & z) | (y & ~z);\n    return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends HashMD {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF_160[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        clean(BUF_160);\n    }\n    destroy() {\n        this.destroyed = true;\n        clean(this.buffer);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nexport const ripemd160 = /* @__PURE__ */ createHasher(() => new RIPEMD160());\n//# sourceMappingURL=legacy.js.map","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from \"./_u64.js\";\n// prettier-ignore\nimport { abytes, aexists, anumber, aoutput, clean, createHasher, createXOFer, Hash, swap32IfBE, toBytes, u32 } from \"./utils.js\";\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst IOTAS = split(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nexport function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    clean(B);\n}\n/** Keccak sponge function. */\nexport class Keccak extends Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        this.enableXOF = false;\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        // Can be passed from user as dkLen\n        anumber(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        // 0 < blockLen < 200\n        if (!(0 < blockLen && blockLen < 200))\n            throw new Error('only keccak-f1600 function is supported');\n        this.state = new Uint8Array(200);\n        this.state32 = u32(this.state);\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    keccak() {\n        swap32IfBE(this.state32);\n        keccakP(this.state32, this.rounds);\n        swap32IfBE(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        const { blockLen, state } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        aexists(this, false);\n        abytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        anumber(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        aoutput(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        clean(this.state);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => createHasher(() => new Keccak(blockLen, suffix, outputLen));\n/** SHA3-224 hash function. */\nexport const sha3_224 = /* @__PURE__ */ (() => gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */\nexport const sha3_256 = /* @__PURE__ */ (() => gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */\nexport const sha3_384 = /* @__PURE__ */ (() => gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */\nexport const sha3_512 = /* @__PURE__ */ (() => gen(0x06, 72, 512 / 8))();\n/** keccak-224 hash function. */\nexport const keccak_224 = /* @__PURE__ */ (() => gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */\nexport const keccak_256 = /* @__PURE__ */ (() => gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */\nexport const keccak_384 = /* @__PURE__ */ (() => gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */\nexport const keccak_512 = /* @__PURE__ */ (() => gen(0x01, 72, 512 / 8))();\nconst genShake = (suffix, blockLen, outputLen) => createXOFer((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\n/** SHAKE128 XOF with 128-bit security. */\nexport const shake128 = /* @__PURE__ */ (() => genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */\nexport const shake256 = /* @__PURE__ */ (() => genShake(0x1f, 136, 256 / 8))();\n//# sourceMappingURL=sha3.js.map","/**\n * 16進文字列をUint8Arrayに変換\n */\nexport const hexToUint8 = (hex: string): Uint8Array => {\n  if (hex.length === 0) return new Uint8Array()\n  return new Uint8Array(hex.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16)))\n}\n\n/**\n * Uint8Arrayを16進文字列に変換\n */\nexport const uint8ToHex = (bytes: Uint8Array): string =>\n  Array.from(bytes, (b) => b.toString(16).padStart(2, '0')).join('')\n","import { ripemd160 } from '@noble/hashes/legacy'\nimport { sha3_256 } from '@noble/hashes/sha3'\nimport { hexToUint8, uint8ToHex } from './convert.js'\n\n/**\n * Base32エンコード/デコード用の文字セット\n */\nconst BASE32_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'\n\n/**\n * HEXアドレスをBase32アドレスに変換\n */\nexport const hexToBase32Address = (hexAddress: string): string => {\n  let bits = 0\n  let value = 0\n  let base32 = ''\n  for (const byte of hexToUint8(hexAddress)) {\n    value = (value << 8) | byte\n    bits += 8\n    while (bits >= 5) {\n      base32 += BASE32_CHARS[(value >>> (bits - 5)) & 0x1f]\n      bits -= 5\n    }\n  }\n  if (bits > 0) base32 += BASE32_CHARS[(value << (5 - bits)) & 0x1f]\n  return base32\n}\n\n/**\n * Base32アドレスをHEXアドレスに変換\n */\nexport const base32ToHexAddress = (base32Address: string): string => {\n  let bits = 0\n  let value = 0\n  let hex = ''\n  for (const char of base32Address) {\n    value = (value << 5) | BASE32_CHARS.indexOf(char)\n    bits += 5\n    while (bits >= 8) {\n      hex += ((value >>> (bits - 8)) & 0xff).toString(16).padStart(2, '0')\n      bits -= 8\n    }\n  }\n  return hex.toUpperCase()\n}\n\n/**\n * 公開鍵からアドレスを生成\n */\nexport const publicKeyToAddress = (networkId: number, publicKey: string): string => {\n  const ripemdHash = ripemd160(sha3_256(hexToUint8(publicKey)))\n  const versionPrefixed = new Uint8Array([networkId, ...ripemdHash])\n  const checksum = sha3_256(versionPrefixed).slice(0, 3)\n  return hexToBase32Address(uint8ToHex(new Uint8Array([...versionPrefixed, ...checksum])))\n}\n","import { base32ToHexAddress, publicKeyToAddress } from './utils/address'\n\n/**\n * ネットワークのネメシス署名者の公開鍵(バーンアドレスとして使用する)\n * TestnetとMainnetで異なるため、環境に応じて使用する\n */\nconst TESTNET_NEMESIS_SIGNER_PUBLIC_KEY = '76E94661562762111FF7E592B00398554973396D8A4B922F3E3D139892F7C35C'\nconst MAINNET_NEMESIS_SIGNER_PUBLIC_KEY = 'BE0B4CF546B7B4F4BBFCFF9F574FDA527C07A53D3FC76F8BB7DB746F8E8E0A9F'\n\n/**\n * ネットワークIDを取得する\n * @param network ネットワーク名\n * @returns ネットワークID\n */\nconst getNetworkId = (network: 'mainnet' | 'testnet'): number => {\n  return network === 'mainnet' ? 104 : 152\n}\n\n/**\n * 転送トランザクションを作成する\n * @param networkName ネットワーク名\n * @param message メッセージ\n * @returns 転送トランザクションHEX\n */\nexport const createSignTx = (networkName: 'mainnet' | 'testnet', message: string) => {\n  const networkId = getNetworkId(networkName)\n\n  const len = 160 + message.length\n  const sizeHex = len.toString(16).padStart(8, '0').toUpperCase()\n  const size = sizeHex.match(/.{2}/g)?.reverse().join('')\n\n  const verifiableEntityHeaderReserved_1 = '00000000'\n  const signature = '0'.repeat(128)\n  const signerPublicKey = '0'.repeat(64)\n  const entityBodyReserved_1 = '00000000'\n  const version = '01'\n  const network = networkId.toString(16).padStart(2, '0').toUpperCase()\n  const type = (16724).toString(16).padStart(4, '0').match(/.{2}/g)!.reverse().join('').toUpperCase()\n  const fee = '0'.repeat(16)\n  const deadline = '0'.repeat(16)\n\n  const recipientPublicKey =\n    networkName === 'testnet' ? TESTNET_NEMESIS_SIGNER_PUBLIC_KEY : MAINNET_NEMESIS_SIGNER_PUBLIC_KEY\n  const recipientAddress = base32ToHexAddress(publicKeyToAddress(networkId, recipientPublicKey))\n\n  const mosaicsCount = '00'\n  const transferTransactionBodyReserved_1 = '00'\n  const transferTransactionBodyReserved_2 = '00000000'\n\n  const encodedMessage = new TextEncoder().encode(message)\n  const messageSizeHex = encodedMessage.length.toString(16).padStart(4, '0').toUpperCase()\n  const messageSize = messageSizeHex.match(/.{2}/g)!.reverse().join('')\n  const messageHex = Array.from(encodedMessage, (byte) => byte.toString(16).padStart(2, '0'))\n    .join('')\n    .toUpperCase()\n\n  // 全体を結合\n  const transaction =\n    size +\n    verifiableEntityHeaderReserved_1 +\n    signature +\n    signerPublicKey +\n    entityBodyReserved_1 +\n    version +\n    network +\n    type +\n    fee +\n    deadline +\n    recipientAddress +\n    messageSize +\n    transferTransactionBodyReserved_1 +\n    transferTransactionBodyReserved_2 +\n    mosaicsCount +\n    messageHex\n\n  return transaction\n}\n","/**\n * モバイルデバイスかどうかを判定する\n * @returns モバイルデバイスの場合はtrue、それ以外はfalse\n */\nexport const isMobileDevice = () => {\n  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)\n}\n"],"names":["getChallenge","async","params","baseUrl","urlParams","URLSearchParams","response_type","client_id","redirect_uri","res","fetch","toString","json","verifySignature","signedTx","form","document","createElement","method","action","style","display","payloadInput","type","name","value","appendChild","body","submit","isBytes","a","Uint8Array","ArrayBuffer","isView","constructor","anumber","n","Number","isSafeInteger","Error","abytes","b","lengths","length","includes","aexists","instance","checkFinished","destroyed","finished","aoutput","out","min","outputLen","u32","arr","Uint32Array","buffer","byteOffset","Math","floor","byteLength","clean","arrays","i","fill","createView","DataView","rotl","word","shift","byteSwap","byteSwap32","swap32IfBE","u","utf8ToBytes","str","TextEncoder","encode","toBytes","data","Hash","createHasher","hashCons","hashC","msg","update","digest","tmp","blockLen","create","setBigUint64","view","isLE","_32n","BigInt","_u32_max","wh","wl","h","l","setUint32","HashMD","padOffset","super","this","pos","len","take","dataView","process","set","subarray","roundClean","digestInto","oview","outLen","state","get","slice","destroy","_cloneInto","to","clone","Rho160","from","Id160","Array","map","_","Pi160","idxLR","j","push","k","idxL","idxR","shifts160","shiftsL160","idx","shiftsR160","Kl160","Kr160","ripemd_f","group","x","y","z","BUF_160","RIPEMD160","h0","h1","h2","h3","h4","offset","getUint32","al","ar","bl","br","cl","cr","dl","dr","el","er","rGroup","hbl","hbr","rl","rr","sl","sr","tl","tr","ripemd160","U32_MASK64","fromBig","le","split","lst","Ah","Al","rotlSH","s","rotlSL","rotlBH","rotlBL","_0n","_1n","_2n","_7n","_256n","_0x71n","SHA3_PI","SHA3_ROTL","_SHA3_IOTA","round","R","t","IOTAS","SHA3_IOTA_H","SHA3_IOTA_L","rotlH","rotlL","keccakP","rounds","B","idx1","idx0","B0","B1","Th","Tl","curH","curL","PI","Keccak","suffix","enableXOF","posOut","state32","keccak","finish","writeInto","bufferOut","xofInto","xof","bytes","gen","sha3_256","hexToUint8","hex","match","byte","parseInt","uint8ToHex","padStart","join","BASE32_CHARS","hexToBase32Address","hexAddress","bits","base32","base32ToHexAddress","base32Address","char","indexOf","toUpperCase","publicKeyToAddress","networkId","publicKey","ripemdHash","versionPrefixed","checksum","TESTNET_NEMESIS_SIGNER_PUBLIC_KEY","MAINNET_NEMESIS_SIGNER_PUBLIC_KEY","getNetworkId","network","createSignTx","networkName","message","sizeHex","size","reverse","verifiableEntityHeaderReserved_1","signature","repeat","signerPublicKey","entityBodyReserved_1","version","fee","deadline","recipientAddress","mosaicsCount","transferTransactionBodyReserved_1","transferTransactionBodyReserved_2","encodedMessage","isMobileDevice","test","navigator","userAgent"],"mappings":"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","x_google_ignoreList":[1,2,3,4,5]}